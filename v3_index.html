<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="Wordpool" />
    <title>Wordpool · Poetry Flow</title>
    <script src="https://cdn.jsdelivr.net/npm/rita"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }

      :root {
        --spring-duration: 600ms;
        --spring-ease: cubic-bezier(0.34, 1.56, 0.64, 1);
        --gentle-ease: cubic-bezier(0.4, 0, 0.2, 1);
        --ink: #1a1a1a;
        --ink-light: #666;
        --ink-whisper: #999;
        --paper: #fafaf9;
        --paper-warm: #f5f5f4;
        --accent: #2563eb;
        --accent-soft: #dbeafe;
        --error: #dc2626;
        --error-soft: #fee2e2;

        /* iOS safe areas */
        --safe-top: env(safe-area-inset-top);
        --safe-bottom: env(safe-area-inset-bottom);
        --safe-left: env(safe-area-inset-left);
        --safe-right: env(safe-area-inset-right);

        /* Keyboard colors */
        --keyboard-bg: #e5e5e7;
        --key-bg: #ffffff;
        --key-active: #d1d1d6;
        --key-text: #000000;
        --key-secondary: #2563eb;
      }

      @supports (font: -apple-system-body) {
        body {
          font: -apple-system-body;
        }
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text",
          "Segoe UI", sans-serif;
        background: var(--paper);
        color: var(--ink);
        line-height: 1.47;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
        overflow-x: hidden;
        /* Prevent rubber-banding on body */
        position: fixed;
        width: 100%;
        height: 100%;
      }

      .app {
        height: 100vh;
        height: 100dvh;
        display: flex;
        flex-direction: column;
        position: relative;
        overflow: hidden;
      }

      /* Header - iOS 44pt touch target minimum */
      .header {
        padding: calc(var(--safe-top) + 20px) max(20px, var(--safe-left)) 16px
          max(20px, var(--safe-right));
        text-align: center;
        background: var(--paper);
        z-index: 10;
        border-bottom: 0.5px solid rgba(0, 0, 0, 0.08);
        flex-shrink: 0;
      }

      .header h1 {
        font-size: 17px;
        font-weight: 600;
        letter-spacing: -0.4px;
        color: var(--ink);
        margin-bottom: 2px;
      }

      .header .step-indicator {
        font-size: 13px;
        color: var(--ink-whisper);
        font-weight: 400;
        letter-spacing: -0.08px;
      }

      /* Back Button */
      .back-button {
        position: absolute;
        left: max(20px, var(--safe-left));
        top: calc(var(--safe-top) + 20px);
        width: 44px;
        height: 44px;
        display: none;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: none;
        cursor: pointer;
        color: var(--ink);
        font-size: 20px;
        line-height: 1;
        padding: 0;
        transition: opacity 0.2s var(--gentle-ease);
        z-index: 11;
        -webkit-tap-highlight-color: transparent;
      }

      .back-button.visible {
        display: flex;
      }

      .back-button:active {
        opacity: 0.6;
      }

      .back-button:focus {
        outline: none;
      }

      @media (min-width: 640px) {
        .back-button {
          left: max(40px, var(--safe-left));
          top: calc(var(--safe-top) + 32px);
        }
      }

      /* Flow Container */
      .flow-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        position: relative;
        min-height: 0; /* Critical for flex scrolling */
      }

      .flow-step {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        flex-direction: column;
        opacity: 0;
        pointer-events: none;
        transform: translateX(10%);
        transition: all 400ms var(--gentle-ease);
        overflow: hidden;
      }

      .flow-step.active {
        opacity: 1;
        pointer-events: all;
        transform: translateX(0) !important;
        position: relative;
        overflow-x: visible !important;
        overflow-y: hidden;
      }

      .flow-step.exiting {
        opacity: 0;
        transform: translateX(-10%);
      }

      .flow-step.exiting-back {
        opacity: 0;
        transform: translateX(20%);
      }

      .flow-step.entering-back {
        opacity: 1;
        transform: translateX(-10%);
      }

      /* Content Padding - iOS spacing conventions */
      .step-content {
        padding: 32px max(20px, var(--safe-left)) 0 max(20px, var(--safe-right));
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
        min-height: 0;
        position: relative;
      }

      /* Step 3 needs padding bottom for keyboard */
      .flow-step#step3 .step-content {
        padding-bottom: calc(var(--safe-bottom) + 280px);
      }

      /* Word bank scroll should extend to edges, so remove step-content padding for it */
      .step-content > .word-bank-scroll {
        margin: 0 calc(-1 * max(20px, var(--safe-left))) 0
          calc(-1 * max(20px, var(--safe-right)));
      }

      /* Prompt Styles */
      .prompt {
        font-size: 17px;
        line-height: 1.47;
        color: var(--ink-light);
        margin-bottom: 28px;
        font-weight: 400;
        letter-spacing: -0.4px;
      }

      .prompt-lg {
        font-size: 20px;
        line-height: 1.4;
        margin-bottom: 32px;
        font-weight: 600;
        letter-spacing: -0.45px;
        color: var(--ink);
      }

      /* Emotion Whisper */
      .emotion-whisper {
        padding: 12px 16px;
        background: linear-gradient(
          135deg,
          var(--accent-soft) 0%,
          transparent 100%
        );
        border-left: 3px solid var(--accent);
        font-size: 15px;
        color: var(--ink-light);
        font-style: italic;
        margin-bottom: 24px;
        border-radius: 8px;
        animation: slideInLeft 0.5s var(--gentle-ease);
        letter-spacing: -0.24px;
      }

      @keyframes slideInLeft {
        from {
          opacity: 0;
          transform: translateX(-10px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      .emotion-whisper strong {
        color: var(--ink);
        font-style: normal;
        font-weight: 600;
      }

      /* Input Styles - iOS native feel */
      .input-wrapper {
        margin-bottom: 24px;
      }

      input[type="text"],
      textarea {
        width: 100%;
        padding: 12px 0;
        border: none;
        border-bottom: 0.5px solid rgba(0, 0, 0, 0.2);
        background: transparent;
        font-size: 17px;
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text",
          sans-serif;
        color: var(--ink);
        transition: border-color 0.3s var(--gentle-ease);
        resize: none;
        line-height: 1.47;
        letter-spacing: -0.4px;
        -webkit-appearance: none;
        appearance: none;
      }

      input[type="text"]:focus,
      textarea:focus {
        outline: none;
        border-bottom-color: var(--accent);
      }

      input[type="text"]::placeholder,
      textarea::placeholder {
        color: var(--ink-whisper);
        font-style: italic;
        opacity: 1;
      }

      textarea {
        min-height: 240px;
        padding-top: 8px;
      }

      /* Poem textarea - contenteditable style */
      .poem-textarea {
        flex: 1;
        background: transparent;
        color: var(--ink);
        border: none;
        border-bottom: 0.5px solid rgba(0, 0, 0, 0.2);
        padding: 12px 0;
        font-size: 17px;
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text",
          sans-serif;
        line-height: 1.7;
        letter-spacing: -0.4px;
        min-height: 200px;
        outline: none;
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-y: auto;
        caret-color: var(--accent);
        transition: border-color 0.3s var(--gentle-ease);
      }

      .poem-textarea:focus {
        border-bottom-color: var(--accent);
      }

      .poem-textarea:empty:before {
        content: attr(data-placeholder);
        color: var(--ink-whisper);
        font-style: italic;
        pointer-events: none;
      }

      /* Word Banks - iOS card design */
      .word-bank-scroll {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
        padding: 0 max(20px, var(--safe-left)) calc(var(--safe-bottom) + 20px)
          max(20px, var(--safe-right));
        overscroll-behavior: contain;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .word-bank-option {
        padding: 16px;
        margin-bottom: 0;
        border-radius: 12px;
        background: white;
        border: 0.5px solid rgba(0, 0, 0, 0.08);
        transition: all 0.2s var(--gentle-ease);
        cursor: pointer;
        position: relative;
        /* iOS shadow depth */
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
        min-height: 44px; /* iOS touch target */
      }

      .word-bank-option:active {
        transform: scale(0.98);
        opacity: 0.9;
      }

      .word-bank-option.selected {
        border-color: var(--accent);
        background: var(--accent-soft);
        box-shadow: 0 2px 8px rgba(37, 99, 235, 0.15);
      }

      .word-bank-option h3 {
        font-size: 13px;
        font-weight: 600;
        color: var(--ink-light);
        margin-bottom: 12px;
        letter-spacing: -0.08px;
        text-transform: uppercase;
      }

      .word-bank-option.selected h3 {
        color: var(--accent);
      }

      .words {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .word {
        padding: 6px 12px;
        background: var(--paper-warm);
        border-radius: 8px;
        font-size: 15px;
        color: var(--ink);
        font-weight: 400;
        transition: all 0.2s var(--gentle-ease);
        letter-spacing: -0.24px;
        line-height: 1.33;
      }

      .word-bank-option.selected .word {
        background: white;
        font-weight: 500;
      }

      /* Selected Bank Display */
      .selected-bank {
        background: white;
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 20px;
        border: 0.5px solid rgba(0, 0, 0, 0.08);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
      }

      .selected-bank .words {
        margin-top: 8px;
      }

      /* Loading State */
      .loading {
        text-align: center;
        color: var(--ink-whisper);
        font-size: 15px;
        font-style: italic;
        padding: 48px 0;
        animation: pulse 2s ease-in-out infinite;
        letter-spacing: -0.24px;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 0.4;
        }
        50% {
          opacity: 1;
        }
      }

      /* Error Messages */
      .error-message {
        background: var(--error-soft);
        border-left: 3px solid var(--error);
        padding: 12px 16px;
        margin: 12px 0;
        font-size: 15px;
        color: var(--error);
        border-radius: 8px;
        line-height: 1.47;
        letter-spacing: -0.24px;
      }

      .error-words {
        font-weight: 600;
      }

      /* Poem Display */
      .poem-display {
        background: white;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
        white-space: pre-wrap;
        font-size: 17px;
        line-height: 1.7;
        color: var(--ink);
        border: 0.5px solid rgba(0, 0, 0, 0.08);
        min-height: 240px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
        letter-spacing: -0.4px;
      }

      /* Buttons - iOS native button styling */
      .button-container {
        padding: 16px max(20px, var(--safe-left))
          calc(var(--safe-bottom) + 16px) max(20px, var(--safe-right));
        background: linear-gradient(to top, var(--paper) 85%, transparent);
        flex-shrink: 0;
        position: relative;
        z-index: 10;
        margin-left: calc(-1 * max(20px, var(--safe-left)) - 20px);
        margin-right: calc(-1 * max(20px, var(--safe-right)) - 20px);
        box-sizing: border-box;
      }

      .button-container button {
        width: 100%;
        box-sizing: border-box;
      }

      @media (min-width: 640px) {
        .button-container {
          background: var(--paper);
          margin-left: -80px !important;
          margin-right: -80px !important;
        }
      }

      button {
        width: 100%;
        padding: 15px;
        border: none;
        border-radius: 12px;
        font-size: 17px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s var(--gentle-ease);
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text",
          sans-serif;
        letter-spacing: -0.4px;
        min-height: 50px; /* iOS 50pt touch target for primary actions */
        -webkit-appearance: none;
        appearance: none;
      }

      button.primary {
        background: var(--accent);
        color: white;
        box-shadow: 0 2px 8px rgba(37, 99, 235, 0.2);
      }

      button.primary:active {
        transform: scale(0.98);
        box-shadow: 0 1px 4px rgba(37, 99, 235, 0.3);
        opacity: 0.9;
      }

      button.primary:disabled {
        background: rgba(0, 0, 0, 0.08);
        color: rgba(0, 0, 0, 0.3);
        box-shadow: none;
        cursor: not-allowed;
      }

      button.secondary {
        background: white;
        color: var(--ink);
        border: 0.5px solid rgba(0, 0, 0, 0.1);
        margin-top: 12px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);
      }

      button.secondary:active {
        transform: scale(0.98);
        background: var(--paper-warm);
        opacity: 0.9;
      }

      /* Tip */
      .tip {
        font-size: 15px;
        color: var(--ink-whisper);
        font-style: italic;
        margin-bottom: 16px;
        display: flex;
        align-items: center;
        gap: 8px;
        letter-spacing: -0.24px;
      }

      /* Custom Keyboard Styles */
      .custom-keyboard {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: var(--keyboard-bg);
        padding: 6px 3px calc(var(--safe-bottom) + 6px) 3px;
        z-index: 1000;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.3);
        border-top: 0.5px solid rgba(0, 0, 0, 0.2);
      }

      .keyboard-group {
        display: none;
      }

      .keyboard-group.active {
        display: block;
      }

      .keyboard-row {
        display: flex;
        gap: 4px;
        margin-bottom: 4px;
        padding: 0 3px;
        justify-content: center;
      }

      .keyboard-row:last-child {
        margin-bottom: 0;
      }

      .keyboard-key {
        flex: 1;
        min-width: 0;
        padding: 12px 8px;
        background: var(--key-bg);
        border: none;
        border-radius: 6px;
        font-size: 15px;
        font-weight: 400;
        color: var(--key-text);
        cursor: pointer;
        min-height: 44px;
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text",
          sans-serif;
        transition: all 0.1s ease;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15);
        touch-action: manipulation;
        letter-spacing: -0.2px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        position: relative;
      }

      .keyboard-key:active {
        background: var(--key-active);
        transform: scale(0.95);
      }

      .keyboard-key.utility {
        background: var(--key-secondary);
        color: white;
        font-weight: 500;
      }

      .keyboard-key.utility:active {
        background: #0051d5;
      }

      .keyboard-key.space {
        flex: 4;
      }

      .keyboard-key.backspace {
        flex: 1.2;
      }

      .keyboard-key.enter {
        flex: 1.2;
      }

      .keyboard-nav {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 8px;
        padding: 8px;
        background: rgba(0, 0, 0, 0.05);
        border-radius: 8px;
        margin: 0 3px 6px 3px;
      }

      .keyboard-nav-btn {
        background: var(--key-bg);
        border: none;
        border-radius: 6px;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 18px;
        color: var(--key-text);
        transition: all 0.1s ease;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      }

      .keyboard-nav-btn:active {
        background: var(--key-active);
        transform: scale(0.95);
      }

      .keyboard-nav-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .keyboard-nav-label {
        flex: 1;
        text-align: center;
        font-size: 13px;
        font-weight: 500;
        color: var(--key-text);
        letter-spacing: -0.1px;
      }

      .keyboard-utility-row {
        display: flex;
        gap: 4px;
        padding: 0 3px;
        margin-top: 4px;
      }

      /* Desktop Responsiveness */
      @media (min-width: 640px) {
        .app {
          max-width: 800px;
          margin: 0 auto;
          box-shadow: 0 0 0 0.5px rgba(0, 0, 0, 0.08);
        }

        .header {
          padding: calc(var(--safe-top) + 32px) max(40px, var(--safe-left)) 24px
            max(40px, var(--safe-right));
        }

        .header h1 {
          font-size: 20px;
        }

        .step-content {
          padding: 24px max(40px, var(--safe-left)) 0
            max(40px, var(--safe-right));
          overflow-y: auto;
          overflow-x: hidden;
          -webkit-overflow-scrolling: touch;
          min-height: 0;
        }

        /* Step 3 needs padding bottom for keyboard */
        .flow-step#step3 .step-content {
          padding-bottom: calc(var(--safe-bottom) + 280px);
        }

        /* Word bank scroll should extend to edges on desktop */
        .step-content > .word-bank-scroll {
          margin: 0 calc(-1 * max(40px, var(--safe-left))) 0
            calc(-1 * max(40px, var(--safe-right)));
        }

        .prompt {
          font-size: 19px;
          margin-bottom: 20px;
        }

        .prompt-lg {
          font-size: 24px;
          margin-bottom: 40px;
        }

        .emotion-whisper {
          padding: 12px 16px;
          margin-bottom: 16px;
          font-size: 15px;
        }

        .input-wrapper {
          margin-bottom: 32px;
        }

        input[type="text"],
        textarea {
          font-size: 19px;
          padding: 14px 0;
        }

        textarea {
          min-height: 280px;
          padding-top: 12px;
        }

        .word-bank-scroll {
          margin: 0;
          padding: 0 max(40px, var(--safe-left)) 24px
            max(40px, var(--safe-right));
          display: grid;
          grid-template-columns: repeat(3, 1fr);
          gap: 12px;
          align-items: start;
          overflow-x: hidden;
          overflow-y: auto;
          flex: 0 1 auto;
        }

        .word-bank-option {
          padding: 12px 14px;
          margin-bottom: 0;
          border-radius: 12px;
        }

        .word-bank-option h3 {
          font-size: 12px;
          margin-bottom: 10px;
        }

        .word-bank-option .words {
          gap: 6px;
        }

        .word {
          padding: 5px 10px;
          font-size: 14px;
          border-radius: 8px;
          line-height: 1.3;
        }

        .selected-bank {
          padding: 20px;
          margin-bottom: 28px;
          border-radius: 16px;
        }

        .selected-bank .words {
          margin-top: 12px;
        }

        .poem-display {
          padding: 28px;
          margin-bottom: 28px;
          font-size: 19px;
          border-radius: 16px;
          min-height: 280px;
        }

        .button-container {
          padding: 24px max(40px, var(--safe-left))
            calc(var(--safe-bottom) + 24px) max(40px, var(--safe-right));
          margin-left: -80px !important;
          margin-right: -80px !important;
          align-self: stretch !important;
          width: 800px !important;
          min-width: 800px !important;
          max-width: 800px !important;
          flex: 0 0 800px !important;
          box-sizing: border-box !important;
        }

        .button-container button {
          width: 100%;
          box-sizing: border-box;
        }

        button {
          padding: 18px;
          font-size: 19px;
          border-radius: 16px;
          min-height: 56px;
        }

        .tip {
          font-size: 16px;
          margin-bottom: 20px;
        }

        .error-message {
          padding: 16px 20px;
          margin: 16px 0;
          font-size: 16px;
        }

        .definition-content {
          padding: 32px;
          max-width: 600px;
        }

        .definition-word {
          font-size: 28px;
          margin-bottom: 16px;
        }

        .definition-meaning {
          font-size: 19px;
          margin-bottom: 20px;
        }

        .keyboard-key {
          padding: 14px 10px;
          font-size: 16px;
        }
      }

      /* Smooth Scrolling - hide scrollbar but keep functionality */
      .word-bank-scroll::-webkit-scrollbar,
      .step-content::-webkit-scrollbar {
        display: none;
      }

      .word-bank-scroll,
      .step-content {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }

      /* Definition Modal */
      .definition-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.4);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 20px;
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
      }

      .definition-modal.active {
        display: flex;
      }

      .definition-content {
        background: white;
        border-radius: 16px;
        padding: 24px;
        max-width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        animation: scaleIn 0.2s var(--gentle-ease);
        position: relative;
      }

      @keyframes scaleIn {
        from {
          opacity: 0;
          transform: scale(0.9);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      .definition-word {
        font-size: 24px;
        font-weight: 600;
        color: var(--ink);
        margin-bottom: 12px;
        letter-spacing: -0.5px;
      }

      .definition-meaning {
        font-size: 17px;
        line-height: 1.6;
        color: var(--ink-light);
        margin-bottom: 16px;
      }

      .definition-close {
        position: absolute;
        top: 16px;
        right: 16px;
        background: transparent;
        border: none;
        font-size: 24px;
        color: var(--ink-whisper);
        cursor: pointer;
        padding: 4px 8px;
        line-height: 1;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 8px;
        transition: all 0.2s var(--gentle-ease);
      }

      .definition-close:hover,
      .definition-close:active {
        background: var(--paper-warm);
        color: var(--ink);
      }

      .definition-loading {
        text-align: center;
        padding: 24px;
        color: var(--ink-whisper);
        font-style: italic;
      }

      .definition-error {
        color: var(--error);
        font-size: 15px;
      }

      /* Make words in poem interactive */
      .poem-display .word {
        cursor: pointer;
        position: relative;
        padding: 2px 4px;
        border-radius: 4px;
        transition: background 0.2s var(--gentle-ease);
      }

      .poem-display .word:hover {
        background: var(--paper-warm);
      }

      /* Word highlight during long press */
      .word.highlighting {
        background: var(--accent-soft);
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="header">
        <button
          class="back-button"
          id="backButton"
          onclick="goBack()"
          aria-label="Go back"
        >
          ←
        </button>
        <h1>Wordpool</h1>
        <div class="step-indicator" id="stepIndicator">Begin</div>
      </div>

      <div class="flow-container">
        <!-- Step 1: Emotion Input -->
        <div class="flow-step active" id="step1">
          <div class="step-content">
            <div class="prompt prompt-lg">
              What emotion has been feeling alive for you lately?
            </div>
            <div class="input-wrapper">
              <input
                type="text"
                id="emotion"
                placeholder="overwhelmed by the vastness of the dictionary"
                autocomplete="off"
                autocapitalize="sentences"
              />
            </div>
          </div>
          <div class="button-container">
            <button class="primary" onclick="generateWordBanks()">
              Continue
            </button>
          </div>
        </div>

        <!-- Step 2: Word Bank Selection -->
        <div class="flow-step" id="step2">
          <div class="step-content">
            <div
              class="emotion-whisper"
              id="emotionDisplay2"
              style="display: none"
            >
              <strong>Feeling:</strong> <span id="emotionText2"></span>
            </div>
            <div class="prompt">Choose the word bank that feels right</div>
            <div class="loading" id="loading">Weaving word banks...</div>
            <div class="word-bank-scroll" id="wordBanks"></div>
          </div>
          <div class="button-container">
            <button
              class="primary"
              id="selectBtn"
              disabled
              onclick="selectWordBank()"
            >
              Continue
            </button>
          </div>
        </div>

        <!-- Step 3: Write Poem -->
        <div class="flow-step" id="step3">
          <div class="step-content">
            <div
              class="emotion-whisper"
              id="emotionDisplay3"
              style="display: none"
            >
              <strong>Feeling:</strong> <span id="emotionText3"></span>
            </div>
            <div
              class="input-wrapper"
              style="
                flex: 1;
                display: flex;
                flex-direction: column;
                border-top: 0.5px solid rgba(0, 0, 0, 0.08);
                padding-top: 20px;
              "
            >
              <div
                class="poem-textarea"
                id="poem"
                contenteditable="true"
                data-placeholder="Write what wants to be written..."
                autocomplete="off"
                autocorrect="off"
                autocapitalize="sentences"
                spellcheck="false"
                inputmode="none"
              ></div>
            </div>
            <div id="poemError"></div>
          </div>
          <div class="button-container">
            <button class="primary" onclick="validateAndShowPoem()">
              Complete
            </button>
          </div>
        </div>

        <!-- Step 4: Poem Display -->
        <div class="flow-step" id="step4">
          <div class="step-content">
            <div
              class="emotion-whisper"
              id="emotionDisplay4"
              style="display: none"
            >
              <strong>Feeling:</strong> <span id="emotionText4"></span>
            </div>
            <div class="poem-display" id="poemDisplay"></div>
          </div>
          <div class="button-container">
            <button class="primary" onclick="createAnother()">
              Create Another
            </button>
            <button class="secondary" onclick="window.location.reload()">
              Start Fresh
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Custom Keyboard -->
    <div class="custom-keyboard" id="customKeyboard" style="display: none">
      <!-- Navigation -->
      <div class="keyboard-nav">
        <button class="keyboard-nav-btn" id="navPrev">‹</button>
        <div class="keyboard-nav-label" id="navLabel">Sky 1</div>
        <button class="keyboard-nav-btn" id="navNext">›</button>
      </div>

      <!-- Word Groups -->
      <div class="keyboard-group active" data-group="0" id="group0"></div>
      <div class="keyboard-group" data-group="1" id="group1"></div>
      <div class="keyboard-group" data-group="2" id="group2"></div>

      <!-- Utility Row -->
      <div class="keyboard-utility-row">
        <button class="keyboard-key space utility" data-action="space">
          space
        </button>
        <button class="keyboard-key backspace utility" data-action="backspace">
          ⌫
        </button>
        <button class="keyboard-key enter utility" data-action="enter">
          return
        </button>
      </div>
    </div>

    <!-- Definition Modal -->
    <div class="definition-modal" id="definitionModal">
      <div class="definition-content">
        <button class="definition-close" onclick="closeDefinitionModal()">
          ×
        </button>
        <div class="definition-word" id="definitionWord"></div>
        <div class="definition-meaning" id="definitionMeaning"></div>
      </div>
    </div>

    <script>
      let wordBanks = [];
      let selectedBankIndex = -1;
      let selectedWordBank = [];
      let currentEmotion = "";
      let currentStep = 1;
      let wordpoolKeyboard = null;

      const stepLabels = ["Begin", "Choose Words", "Write", "Complete"];

      // Problem statement suggestions - emotions related to being overwhelmed by language
      // These capture the core problem Wordpool solves: the paralysis of choice when facing infinite word possibilities
      const emotionPlaceholders = [
        "overwhelmed by the vastness of the dictionary",
        "drowning in too many word choices",
        "paralyzed by infinite language possibilities",
        "lost in a sea of synonyms and meanings",
        "searching for words that feel just right",
        "struggling to find the perfect expression",
        "feeling small against the enormity of language",
        "too many words, none quite right",
        "drowning in an ocean of vocabulary",
        "paralyzed by the weight of choice",
        "lost in the maze of language",
        "searching for words that resonate",
        "overwhelmed by linguistic abundance",
        "stuck between too many possibilities",
        "can't find the word that captures it",
        "drowning in synonyms and antonyms",
        "paralyzed by perfect possibilities",
        "lost in translation between feeling and word",
        "searching for clarity in the chaos of words",
        "overwhelmed by the infinity of expression",
        "drowning in the depth of language",
        "paralyzed by the fear of choosing wrong",
        "lost in the space between thought and word",
        "searching for meaning in the noise",
        "overwhelmed by what words could be",
        "drowning in what words might mean",
        "paralyzed by the responsibility of language",
        "lost in the gap between feeling and phrase",
        "searching for the word that fits like a key",
        "overwhelmed by the power words hold",
      ];

      function showStep(stepNumber) {
        const steps = document.querySelectorAll(".flow-step");
        const currentStepEl = steps[currentStep - 1];
        const nextStepEl = steps[stepNumber - 1];
        const isGoingBack = stepNumber < currentStep;

        if (currentStepEl) {
          if (isGoingBack) {
            currentStepEl.classList.add("exiting-back");
          } else {
            currentStepEl.classList.add("exiting");
          }
          setTimeout(() => {
            currentStepEl.classList.remove("active", "exiting", "exiting-back");
          }, 400);
        }

        if (nextStepEl) {
          if (isGoingBack) {
            // Position the step to the left before animating in
            nextStepEl.classList.add("entering-back");
            // Force a reflow to ensure the class is applied
            nextStepEl.offsetHeight;
          }
          // Start animation immediately - no delay
          requestAnimationFrame(() => {
            nextStepEl.classList.add("active");
            if (isGoingBack) {
              nextStepEl.classList.remove("entering-back");
            }
            currentStep = stepNumber;
            document.getElementById("stepIndicator").textContent =
              stepLabels[stepNumber - 1] || "";
            updateBackButtonVisibility();

            // Show/hide keyboard based on step
            const keyboard = document.getElementById("customKeyboard");
            if (stepNumber === 3 && selectedWordBank.length > 0) {
              keyboard.style.display = "block";
              if (wordpoolKeyboard) {
                wordpoolKeyboard.updateWordBank(selectedWordBank);
              }
            } else {
              keyboard.style.display = "none";
            }
          });
        }
      }

      function updateBackButtonVisibility() {
        const backButton = document.getElementById("backButton");
        if (backButton) {
          // Show back button if not on step 1
          if (currentStep > 1) {
            backButton.classList.add("visible");
          } else {
            backButton.classList.remove("visible");
          }
        }
      }

      function goBack() {
        if (currentStep > 1) {
          showStep(currentStep - 1);
        }
      }

      function generateBasicWords() {
        const basicWords = new Set();
        const posCategories = {
          pronouns: ["prp", "prp$"],
          conjunctions: ["cc"],
          determiners: ["dt", "pdt"],
          prepositions: ["in"],
          verbs: ["vb", "vbd", "vbg", "vbn", "vbp", "vbz"],
          whWords: ["wdt", "wp", "wp$", "wrb"],
          adverbs: ["rb"],
          modals: ["md"],
          particles: ["rp"],
          to: ["to"],
        };

        Object.keys(posCategories).forEach((category) => {
          posCategories[category].forEach((pos) => {
            try {
              const word = RiTa.randomWord({ pos });
              if (word && word.length > 0) {
                basicWords.add(word.toLowerCase());
              }
            } catch (e) {}
          });
        });

        const importantCategories = {
          pronouns: ["prp", "prp$"],
          conjunctions: ["cc"],
          determiners: ["dt"],
          prepositions: ["in"],
          verbs: ["vb", "vbd", "vbz", "vbp"],
          whWords: ["wdt", "wp", "wrb"],
        };

        Object.keys(importantCategories).forEach((category) => {
          const attempts = 3;
          for (let i = 0; i < attempts; i++) {
            const posArray = importantCategories[category];
            const randomPos =
              posArray[Math.floor(Math.random() * posArray.length)];
            try {
              const word = RiTa.randomWord({ pos: randomPos });
              if (word && word.length > 0) {
                basicWords.add(word.toLowerCase());
              }
            } catch (e) {}
          }
        });

        if (basicWords.size < 10) {
          const fallbackPos = ["dt", "prp", "cc", "in", "vb", "rb"];
          fallbackPos.forEach((pos) => {
            if (basicWords.size >= 15) return;
            try {
              const word = RiTa.randomWord({ pos });
              if (word && word.length > 0) {
                basicWords.add(word.toLowerCase());
              }
            } catch (e) {}
          });
        }

        return Array.from(basicWords);
      }

      function generateWordBank(emotionText) {
        const basicWords = generateBasicWords();
        const words = RiTa.tokenize(emotionText);
        const poses = RiTa.pos(emotionText);

        const uniquePOS = [
          ...new Set(
            poses.filter(
              (pos) =>
                pos &&
                pos.length > 0 &&
                ![".", ",", "!", "?", ":", ";", "..."].includes(pos)
            )
          ),
        ];

        const wordBank = new Set();
        const posTypes = ["nn", "jj", "vb", "rb", "prp", "dt"];

        const shuffledBasic = [...basicWords].sort(() => Math.random() - 0.5);
        const basicCount = Math.min(
          Math.floor(Math.random() * 3) + 8,
          shuffledBasic.length,
          25 - wordBank.size
        );
        for (let i = 0; i < basicCount && wordBank.size < 25; i++) {
          if (shuffledBasic[i]) {
            wordBank.add(shuffledBasic[i]);
          }
        }

        uniquePOS.forEach((pos) => {
          if (wordBank.size < 25) {
            try {
              const word = RiTa.randomWord({ pos });
              if (word && word.length > 0) {
                wordBank.add(word.toLowerCase());
              }
            } catch (e) {}
          }
        });

        while (wordBank.size < 25) {
          try {
            const randomPos =
              posTypes[Math.floor(Math.random() * posTypes.length)];
            const word = RiTa.randomWord({
              pos: randomPos,
              syllables: Math.floor(Math.random() * 3) + 1,
            });
            if (word && word.length > 0) {
              wordBank.add(word.toLowerCase());
            }
          } catch (e) {
            try {
              const word = RiTa.randomWord({
                syllables: Math.floor(Math.random() * 3) + 1,
              });
              if (word && word.length > 0) {
                wordBank.add(word.toLowerCase());
              }
            } catch (e2) {
              const remainingBasic = shuffledBasic.filter(
                (w) => !wordBank.has(w)
              );
              if (remainingBasic.length > 0 && wordBank.size < 25) {
                wordBank.add(remainingBasic[0]);
              } else {
                break;
              }
            }
          }
        }

        const bankArray = Array.from(wordBank).sort();
        return bankArray.slice(0, 25);
      }

      function updateEmotionDisplay(emotion) {
        currentEmotion = emotion;
        for (let i = 2; i <= 4; i++) {
          const display = document.getElementById(`emotionDisplay${i}`);
          const text = document.getElementById(`emotionText${i}`);
          if (display && text) {
            text.textContent = emotion;
            display.style.display = "block";
          }
        }
      }

      function generateWordBanks() {
        const emotion = document.getElementById("emotion").value.trim();

        if (!emotion || emotion.length < 3) {
          return;
        }

        updateEmotionDisplay(emotion);
        showStep(2);
        document.getElementById("loading").style.display = "block";
        document.getElementById("wordBanks").innerHTML = "";

        wordBanks = [];
        for (let i = 0; i < 3; i++) {
          wordBanks.push(generateWordBank(emotion));
        }

        setTimeout(() => {
          document.getElementById("loading").style.display = "none";
          const container = document.getElementById("wordBanks");

          wordBanks.forEach((bank, index) => {
            const option = document.createElement("div");
            option.className = "word-bank-option";
            option.dataset.index = index;
            option.onclick = () => selectBankOption(index);

            const title = document.createElement("h3");
            title.textContent = `Option ${index + 1}`;
            option.appendChild(title);

            const wordsDiv = document.createElement("div");
            wordsDiv.className = "words";
            bank.forEach((word) => {
              const wordSpan = document.createElement("span");
              wordSpan.className = "word";
              wordSpan.textContent = word;
              setupLongPress(wordSpan);
              wordsDiv.appendChild(wordSpan);
            });
            option.appendChild(wordsDiv);

            container.appendChild(option);
          });
        }, 600);
      }

      function selectBankOption(index) {
        selectedBankIndex = index;

        document.querySelectorAll(".word-bank-option").forEach((opt, i) => {
          if (i === index) {
            opt.classList.add("selected");
          } else {
            opt.classList.remove("selected");
          }
        });

        document.getElementById("selectBtn").disabled = false;
      }

      // Prevent word bank option click if word was long-pressed
      document.addEventListener(
        "click",
        (e) => {
          const word = e.target.closest(".word");
          if (word && word.classList.contains("highlighting")) {
            // Recently long-pressed, prevent parent click
            const option = word.closest(".word-bank-option");
            if (option) {
              e.stopPropagation();
              e.preventDefault();
            }
            word.classList.remove("highlighting");
          }
        },
        true
      );

      function selectWordBank() {
        if (selectedBankIndex === -1) return;

        selectedWordBank = wordBanks[selectedBankIndex];
        showStep(3);

        // Initialize keyboard with selected word bank
        const poemTextarea = document.getElementById("poem");
        if (poemTextarea && selectedWordBank.length > 0) {
          wordpoolKeyboard = new WordpoolKeyboard(
            poemTextarea,
            selectedWordBank
          );
        }
      }

      function validatePoem(poem, wordBank) {
        const normalizeWord = (word) =>
          word.toLowerCase().replace(/[^\w]/g, "");
        const bankSet = new Set(wordBank.map(normalizeWord));

        const invalidWords = RiTa.tokenize(poem.toLowerCase())
          .map(normalizeWord)
          .filter((word) => word.length > 0 && !bankSet.has(word));

        return {
          valid: invalidWords.length === 0,
          invalidWords: [...new Set(invalidWords)],
        };
      }

      function validateAndShowPoem() {
        const poemEl = document.getElementById("poem");
        const poem = poemEl ? poemEl.textContent.trim() : "";
        const errorDiv = document.getElementById("poemError");

        if (!poem || poem.length < 5) {
          errorDiv.innerHTML =
            '<div class="error-message">Write a few words first</div>';
          return;
        }

        const validation = validatePoem(poem, selectedWordBank);

        if (validation.valid) {
          errorDiv.innerHTML = "";
          const poemDisplay = document.getElementById("poemDisplay");
          poemDisplay.textContent = poem;
          showStep(4);
          setTimeout(() => {
            makePoemWordsInteractive();
          }, 150);
        } else {
          errorDiv.innerHTML = `<div class="error-message">Words not in your bank: <span class="error-words">${validation.invalidWords.join(
            ", "
          )}</span></div>`;
        }
      }

      function createAnother() {
        const poemEl = document.getElementById("poem");
        if (poemEl) {
          poemEl.textContent = "";
        }
        document.getElementById("poemError").innerHTML = "";
        selectedBankIndex = -1;
        selectedWordBank = [];
        wordBanks = [];

        for (let i = 2; i <= 4; i++) {
          const display = document.getElementById(`emotionDisplay${i}`);
          if (display) {
            display.style.display = "none";
          }
        }

        showStep(3);
      }

      // Enter key handling
      document.getElementById("emotion").addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          generateWordBanks();
        }
      });

      // WordpoolKeyboard Class - adapted for word bank constraint
      class WordpoolKeyboard {
        constructor(targetTextarea, wordBank) {
          this.targetTextarea = targetTextarea;
          this.wordBank = wordBank || [];
          this.groups = [];
          this.currentGroupIndex = 0;
          this.savedRange = null;

          this.init();
        }

        init() {
          this.groupWords();
          this.renderGroups();
          this.attachEventListeners();
          this.updateNavigation();
          this.setupCursorTracking();
        }

        setupCursorTracking() {
          const element = this.targetTextarea;

          element.addEventListener("click", () => {
            this.saveCursorPosition();
          });

          element.addEventListener("keyup", () => {
            this.saveCursorPosition();
          });

          document.addEventListener("selectionchange", () => {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
              const range = selection.getRangeAt(0);
              if (element.contains(range.commonAncestorContainer)) {
                this.savedRange = range.cloneRange();
              }
            }
          });
        }

        saveCursorPosition() {
          const selection = window.getSelection();
          if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const element = this.targetTextarea;
            if (element.contains(range.commonAncestorContainer)) {
              this.savedRange = range.cloneRange();
            }
          }
        }

        // Group words from selected word bank into Grounded/Sky 1/Sky 2
        groupWords() {
          const grounded = [];
          const sky1 = [];
          const sky2 = [];

          // Common connecting words and pronouns
          const connectorWords = new Set([
            "the",
            "and",
            "or",
            "but",
            "for",
            "with",
            "from",
            "into",
            "upon",
            "about",
            "above",
            "across",
            "after",
            "against",
            "along",
            "among",
            "around",
            "at",
            "before",
            "behind",
            "below",
            "beneath",
            "beside",
            "between",
            "beyond",
            "by",
            "during",
            "except",
            "inside",
            "near",
            "of",
            "off",
            "on",
            "onto",
            "out",
            "outside",
            "over",
            "past",
            "since",
            "through",
            "throughout",
            "till",
            "to",
            "toward",
            "under",
            "until",
            "up",
            "via",
            "within",
            "without",
            "a",
            "an",
            "as",
            "be",
            "do",
            "go",
            "he",
            "if",
            "in",
            "is",
            "it",
            "me",
            "my",
            "no",
            "so",
            "we",
            "am",
            "are",
            "was",
            "were",
            "been",
            "have",
            "has",
            "had",
            "this",
            "that",
            "these",
            "those",
            "what",
            "when",
            "where",
            "which",
            "who",
            "whom",
            "whose",
            "why",
            "how",
            "all",
            "any",
            "each",
            "every",
            "some",
            "both",
            "either",
            "neither",
            "one",
            "two",
            "three",
            "more",
            "most",
            "much",
            "many",
            "few",
            "little",
            "less",
            "least",
            "other",
            "another",
            "such",
            "same",
            "own",
            "very",
            "too",
            "also",
            "just",
            "only",
            "even",
            "still",
            "yet",
            "again",
            "once",
            "then",
            "now",
            "here",
            "there",
            "well",
            "quite",
            "rather",
            "than",
            "like",
            "i",
            "you",
            "he",
            "she",
            "it",
            "we",
            "they",
            "me",
            "him",
            "her",
            "us",
            "them",
            "my",
            "your",
            "his",
            "her",
            "its",
            "our",
            "their",
            "mine",
            "yours",
            "hers",
            "ours",
            "theirs",
            "myself",
            "yourself",
            "himself",
            "herself",
            "itself",
            "ourselves",
            "yourselves",
            "themselves",
          ]);

          this.wordBank.forEach((word) => {
            const lowerWord = word.toLowerCase();
            const len = word.length;

            if (connectorWords.has(lowerWord)) {
              grounded.push(word);
            } else if (len >= 8) {
              sky2.push(word);
            } else if (len >= 5 && len <= 7) {
              sky1.push(word);
            } else {
              grounded.push(word);
            }
          });

          grounded.sort();
          sky1.sort();
          sky2.sort();

          this.groups = [grounded, sky1, sky2].filter((g) => g.length > 0);
          this.currentGroupIndex =
            this.groups.length > 1 && this.groups[1] ? 1 : 0;
        }

        layoutWordsInRows(words) {
          if (words.length === 0) return [];
          const targetRows = Math.min(
            Math.max(Math.ceil(words.length / 6), 2),
            4
          );
          const wordsPerRow = Math.ceil(words.length / targetRows);
          const rows = [];
          for (let i = 0; i < words.length; i += wordsPerRow) {
            rows.push(words.slice(i, i + wordsPerRow));
          }
          return rows;
        }

        renderGroups() {
          this.groups.forEach((group, groupIndex) => {
            const container = document.getElementById(`group${groupIndex}`);
            if (!container) return;
            container.innerHTML = "";
            const rows = this.layoutWordsInRows(group);
            rows.forEach((row) => {
              const rowEl = document.createElement("div");
              rowEl.className = "keyboard-row";
              row.forEach((word) => {
                const key = document.createElement("button");
                key.className = "keyboard-key";
                key.textContent = word;
                key.dataset.word = word;
                key.addEventListener("click", () => this.insertWord(word));
                rowEl.appendChild(key);
              });
              container.appendChild(rowEl);
            });
          });
        }

        attachEventListeners() {
          document
            .getElementById("navPrev")
            .addEventListener("click", () => this.prevGroup());
          document
            .getElementById("navNext")
            .addEventListener("click", () => this.nextGroup());

          document.querySelectorAll("[data-action]").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const action = e.target.dataset.action;
              this.handleUtilityAction(action);
            });
          });

          document.addEventListener("keydown", (e) => {
            if (e.key === "ArrowLeft" && (e.metaKey || e.ctrlKey)) {
              e.preventDefault();
              this.prevGroup();
            } else if (e.key === "ArrowRight" && (e.metaKey || e.ctrlKey)) {
              e.preventDefault();
              this.nextGroup();
            }
          });

          this.setupSwipeGestures();
        }

        setupSwipeGestures() {
          const keyboard = document.getElementById("customKeyboard");
          let touchStartX = 0;
          let touchEndX = 0;
          const minSwipeDistance = 50;

          keyboard.addEventListener(
            "touchstart",
            (e) => {
              touchStartX = e.changedTouches[0].screenX;
            },
            { passive: true }
          );

          keyboard.addEventListener(
            "touchend",
            (e) => {
              touchEndX = e.changedTouches[0].screenX;
              this.handleSwipe(touchStartX, touchEndX, minSwipeDistance);
            },
            { passive: true }
          );

          let mouseDownX = 0;
          let isDragging = false;

          keyboard.addEventListener("mousedown", (e) => {
            mouseDownX = e.clientX;
            isDragging = true;
          });

          keyboard.addEventListener("mousemove", (e) => {
            if (!isDragging) return;
            e.preventDefault();
          });

          keyboard.addEventListener("mouseup", (e) => {
            if (!isDragging) return;
            isDragging = false;
            const mouseUpX = e.clientX;
            this.handleSwipe(mouseDownX, mouseUpX, minSwipeDistance);
          });

          keyboard.addEventListener("mouseleave", () => {
            isDragging = false;
          });
        }

        handleSwipe(startX, endX, minDistance) {
          const swipeDistance = endX - startX;
          if (Math.abs(swipeDistance) < minDistance) return;
          if (swipeDistance > 0) {
            this.prevGroup();
          } else {
            this.nextGroup();
          }
        }

        prevGroup() {
          if (this.currentGroupIndex > 0) {
            this.currentGroupIndex--;
            this.updateActiveGroup();
            this.updateNavigation();
          }
        }

        nextGroup() {
          if (this.currentGroupIndex < this.groups.length - 1) {
            this.currentGroupIndex++;
            this.updateActiveGroup();
            this.updateNavigation();
          }
        }

        updateActiveGroup() {
          document
            .querySelectorAll(".keyboard-group")
            .forEach((group, index) => {
              if (index === this.currentGroupIndex) {
                group.classList.add("active");
              } else {
                group.classList.remove("active");
              }
            });
        }

        updateNavigation() {
          const prevBtn = document.getElementById("navPrev");
          const nextBtn = document.getElementById("navNext");
          const label = document.getElementById("navLabel");

          prevBtn.disabled = this.currentGroupIndex === 0;
          nextBtn.disabled = this.currentGroupIndex === this.groups.length - 1;

          const groupNames = ["Grounded", "Sky 1", "Sky 2"];
          const actualIndex = this.getActualGroupIndex(this.currentGroupIndex);
          label.textContent =
            groupNames[actualIndex] || `Group ${this.currentGroupIndex + 1}`;
        }

        getActualGroupIndex(currentIndex) {
          if (
            !this.groups[currentIndex] ||
            this.groups[currentIndex].length === 0
          ) {
            return currentIndex;
          }

          const sampleWord = this.groups[currentIndex][0].toLowerCase();
          const len = sampleWord.length;
          const connectorWords = new Set([
            "the",
            "and",
            "or",
            "but",
            "for",
            "with",
            "from",
            "about",
            "into",
            "upon",
            "i",
            "you",
            "he",
            "she",
            "it",
            "we",
            "they",
            "me",
            "him",
            "her",
            "us",
            "them",
            "my",
            "your",
            "his",
            "her",
            "its",
            "our",
            "their",
          ]);

          if (connectorWords.has(sampleWord) || len <= 4) {
            return 0;
          } else if (len >= 8) {
            return 2;
          } else {
            return 1;
          }
        }

        insertWord(word) {
          if (!this.targetTextarea) return;
          const element = this.targetTextarea;
          element.focus();

          const selection = window.getSelection();
          let range = null;

          if (selection.rangeCount > 0) {
            const currentRange = selection.getRangeAt(0);
            if (element.contains(currentRange.commonAncestorContainer)) {
              range = currentRange;
            }
          }

          if (!range && this.savedRange) {
            try {
              if (element.contains(this.savedRange.commonAncestorContainer)) {
                range = this.savedRange.cloneRange();
                selection.removeAllRanges();
                selection.addRange(range);
              }
            } catch (e) {}
          }

          if (!range) {
            range = document.createRange();
            range.selectNodeContents(element);
            range.collapse(false);
            selection.removeAllRanges();
            selection.addRange(range);
          }

          const textNode = document.createTextNode(word + " ");
          range.insertNode(textNode);
          range.setStartAfter(textNode);
          range.collapse(true);
          selection.removeAllRanges();
          selection.addRange(range);
          this.savedRange = range.cloneRange();

          const event = new Event("input", { bubbles: true });
          element.dispatchEvent(event);
        }

        handleUtilityAction(action) {
          if (!this.targetTextarea) return;
          const element = this.targetTextarea;
          element.focus();

          const selection = window.getSelection();
          let range = null;

          if (selection.rangeCount > 0) {
            const currentRange = selection.getRangeAt(0);
            if (element.contains(currentRange.commonAncestorContainer)) {
              range = currentRange;
            }
          }

          if (!range && this.savedRange) {
            try {
              if (element.contains(this.savedRange.commonAncestorContainer)) {
                range = this.savedRange.cloneRange();
                selection.removeAllRanges();
                selection.addRange(range);
              }
            } catch (e) {}
          }

          if (!range) {
            range = document.createRange();
            range.selectNodeContents(element);
            range.collapse(false);
            selection.removeAllRanges();
            selection.addRange(range);
          }

          switch (action) {
            case "space":
              this.insertText(" ");
              break;
            case "backspace":
              if (range.collapsed) {
                if (range.startOffset > 0) {
                  range.setStart(range.startContainer, range.startOffset - 1);
                  range.deleteContents();
                }
              } else {
                range.deleteContents();
              }
              selection.removeAllRanges();
              selection.addRange(range);
              const backspaceEvent = new Event("input", { bubbles: true });
              element.dispatchEvent(backspaceEvent);
              break;
            case "enter":
              this.insertText("\n");
              break;
          }
        }

        insertText(text) {
          if (!this.targetTextarea) return;
          const element = this.targetTextarea;
          element.focus();

          const selection = window.getSelection();
          if (selection.rangeCount === 0) {
            const range = document.createRange();
            range.selectNodeContents(element);
            range.collapse(false);
            selection.addRange(range);
          }
          const range = selection.getRangeAt(0);
          const textNode = document.createTextNode(text);
          range.insertNode(textNode);
          range.setStartAfter(textNode);
          range.collapse(true);
          selection.removeAllRanges();
          selection.addRange(range);

          const event = new Event("input", { bubbles: true });
          element.dispatchEvent(event);
        }

        updateWordBank(newWordBank) {
          this.wordBank = newWordBank || [];
          this.groupWords();
          this.renderGroups();
          this.updateActiveGroup();
          this.updateNavigation();
        }
      }

      // Long press detection for definitions
      const LONG_PRESS_DURATION = 500;
      const longPressTimers = new WeakMap();
      const longPressStates = new WeakMap();

      function setupWordInteractions() {
        document.querySelectorAll(".word").forEach((wordEl) => {
          setupLongPress(wordEl);
        });
      }

      function setupLongPress(element) {
        if (element.dataset.definitionSetup === "true") return;
        element.dataset.definitionSetup = "true";

        const startLongPress = (e) => {
          longPressStates.set(element, false);
          let word = element.textContent.trim();
          if (!word) return;
          const cleanWord = word.replace(/[^\w]/g, "").toLowerCase();
          if (!cleanWord || cleanWord.length === 0) return;

          const existingTimer = longPressTimers.get(element);
          if (existingTimer) {
            clearTimeout(existingTimer);
          }

          const timer = setTimeout(() => {
            longPressStates.set(element, true);
            element.classList.add("highlighting");
            showDefinition(cleanWord, element);
          }, LONG_PRESS_DURATION);

          longPressTimers.set(element, timer);

          if (!element.closest(".word-bank-option")) {
            e.preventDefault();
          }
        };

        const endLongPress = (e) => {
          const timer = longPressTimers.get(element);
          if (timer) {
            clearTimeout(timer);
            longPressTimers.delete(element);
          }

          const wasLongPress = longPressStates.get(element);
          element.classList.remove("highlighting");

          if (wasLongPress) {
            e.preventDefault();
            e.stopPropagation();
          }

          longPressStates.delete(element);
        };

        element.addEventListener("touchstart", startLongPress, {
          passive: false,
        });
        element.addEventListener("touchend", endLongPress, { passive: false });
        element.addEventListener("touchcancel", endLongPress);
        element.addEventListener("touchmove", endLongPress);
        element.addEventListener("mousedown", startLongPress);
        element.addEventListener("mouseup", endLongPress);
        element.addEventListener("mouseleave", endLongPress);
        element.addEventListener("dragstart", (e) => {
          const timer = longPressTimers.get(element);
          if (timer) {
            clearTimeout(timer);
            longPressTimers.delete(element);
          }
          endLongPress(e);
        });
      }

      function getBaseWord(word) {
        if (word.length < 4) return null;
        const suffixes = [
          { pattern: /edly$/, remove: 4 },
          { pattern: /ingly$/, remove: 5 },
          { pattern: /iedly$/, remove: 5, replace: "y" },
          { pattern: /ly$/, remove: 2 },
          { pattern: /ying$/, remove: 4, replace: "y" },
          { pattern: /ying$/, remove: 4, replace: "ie" },
          { pattern: /ying$/, remove: 4 },
          { pattern: /ing$/, remove: 3 },
          { pattern: /ied$/, remove: 4, replace: "y" },
          { pattern: /ied$/, remove: 3, replace: "y" },
          { pattern: /ed$/, remove: 2 },
          { pattern: /er$/, remove: 2 },
          { pattern: /est$/, remove: 3 },
          { pattern: /ies$/, remove: 4, replace: "y" },
          { pattern: /es$/, remove: 2 },
          { pattern: /s$/, remove: 1 },
        ];

        for (const suffix of suffixes) {
          if (suffix.pattern.test(word) && word.length > suffix.remove + 2) {
            let result;
            if (suffix.replace) {
              result = word.slice(0, -suffix.remove) + suffix.replace;
            } else {
              result = word.slice(0, -suffix.remove);
            }
            if (result !== word && result.length > 2) {
              return result;
            }
          }
        }
        return null;
      }

      async function fetchDefinition(word) {
        const response = await fetch(
          `https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(
            word
          )}`,
          {
            method: "GET",
            headers: {
              Accept: "application/json",
            },
          }
        );

        if (!response.ok) {
          if (response.status === 404) {
            return { error: "not_found", status: 404 };
          }
          return { error: "api_error", status: response.status };
        }

        const data = await response.json();
        return { data, error: null };
      }

      async function showDefinition(word, element) {
        const modal = document.getElementById("definitionModal");
        const wordEl = document.getElementById("definitionWord");
        const meaningEl = document.getElementById("definitionMeaning");

        if (!word || word.length === 0) return;

        modal.classList.add("active");
        wordEl.textContent = word;
        meaningEl.innerHTML =
          '<div class="definition-loading">Looking up definition...</div>';

        try {
          let result = await fetchDefinition(word);
          let triedWords = [word];
          let foundBaseWord = null;

          if (result.error === "not_found") {
            let currentWord = word;
            let attempts = 0;
            const maxAttempts = 2;

            while (attempts < maxAttempts && result.error === "not_found") {
              const baseWord = getBaseWord(currentWord);
              if (
                !baseWord ||
                baseWord === currentWord ||
                baseWord.length < 3
              ) {
                break;
              }

              if (triedWords.includes(baseWord)) {
                break;
              }

              triedWords.push(baseWord);
              meaningEl.innerHTML = `<div class="definition-loading">Trying "${baseWord}"...</div>`;

              result = await fetchDefinition(baseWord);
              if (result.data) {
                foundBaseWord = baseWord;
                break;
              }

              currentWord = baseWord;
              attempts++;
            }
          }

          if (foundBaseWord) {
            wordEl.textContent = `${word} (from "${foundBaseWord}")`;
          }

          if (result.error) {
            if (result.error === "not_found") {
              meaningEl.innerHTML =
                '<div class="definition-error">Definition not found for this word.</div>';
            } else if (result.error === "api_error") {
              meaningEl.innerHTML =
                '<div class="definition-error">Dictionary service unavailable. Please try again later.</div>';
            } else {
              throw new Error("Unknown error");
            }
            return;
          }

          const data = result.data;
          if (data && data.length > 0) {
            const entry = data[0];
            let definitionHTML = "";

            if (entry.meanings && entry.meanings.length > 0) {
              const firstMeaning = entry.meanings[0];
              if (
                firstMeaning.definitions &&
                firstMeaning.definitions.length > 0
              ) {
                const firstDef = firstMeaning.definitions[0];
                definitionHTML = `<p><strong>${
                  firstMeaning.partOfSpeech || ""
                }</strong> ${
                  firstDef.definition || "No definition available."
                }</p>`;

                if (firstDef.example) {
                  definitionHTML += `<p style="margin-top: 12px; font-style: italic; color: var(--ink-whisper);">"${firstDef.example}"</p>`;
                }
              } else {
                definitionHTML = "<p>No definition available.</p>";
              }
            } else {
              definitionHTML = "<p>No definition available.</p>";
            }

            meaningEl.innerHTML = definitionHTML;
          } else {
            meaningEl.innerHTML =
              '<div class="definition-error">Definition not found.</div>';
          }
        } catch (error) {
          console.error("Definition lookup error:", error);
          meaningEl.innerHTML =
            '<div class="definition-error">Network error. Please check your connection and try again.</div>';
        }
      }

      function closeDefinitionModal(event) {
        document.getElementById("definitionModal").classList.remove("active");
      }

      function makePoemWordsInteractive() {
        const poemDisplay = document.getElementById("poemDisplay");
        if (!poemDisplay || poemDisplay.dataset.wordsInteractive === "true")
          return;
        poemDisplay.dataset.wordsInteractive = "true";

        const text = poemDisplay.textContent;
        const parts = text.split(/(\s+|[^\w\s])/);

        poemDisplay.innerHTML = "";
        parts.forEach((part) => {
          if (!part) return;

          if (/\w/.test(part)) {
            const wordSpan = document.createElement("span");
            wordSpan.className = "word";
            wordSpan.textContent = part;
            setupLongPress(wordSpan);
            poemDisplay.appendChild(wordSpan);
          } else {
            const textNode = document.createTextNode(part);
            poemDisplay.appendChild(textNode);
          }
        });
      }

      // Setup interactions on page load
      document.addEventListener("DOMContentLoaded", () => {
        const emotionInput = document.getElementById("emotion");
        if (emotionInput && emotionPlaceholders.length > 0) {
          const randomPlaceholder =
            emotionPlaceholders[
              Math.floor(Math.random() * emotionPlaceholders.length)
            ];
          emotionInput.placeholder = randomPlaceholder;
        }

        const modal = document.getElementById("definitionModal");
        if (modal) {
          modal.addEventListener("click", (e) => {
            if (e.target === modal) {
              closeDefinitionModal();
            }
          });
        }

        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            if (modal && modal.classList.contains("active")) {
              closeDefinitionModal();
            }
          }
        });

        setTimeout(() => {
          setupWordInteractions();
        }, 1000);

        updateBackButtonVisibility();

        // Keep textarea focused when clicking on keyboard
        const keyboard = document.getElementById("customKeyboard");
        if (keyboard) {
          keyboard.addEventListener("click", () => {
            const poemEl = document.getElementById("poem");
            if (poemEl) {
              setTimeout(() => {
                poemEl.focus();
              }, 10);
            }
          });
        }
      });
    </script>
  </body>
</html>
